function assertNonEmptyString(e){if("string"!=typeof e||!e)throw new Error("expected a non-empty string, got: "+e)}function assertNumber(e){if("number"!=typeof e)throw new Error("expected a number, got: "+e)}const DB_VERSION_CURRENT=1,DB_VERSION_INITIAL=1,STORE_EMOJI="emoji",STORE_KEYVALUE="keyvalue",STORE_FAVORITES="favorites",FIELD_TOKENS="tokens",INDEX_TOKENS="tokens",FIELD_UNICODE="unicode",INDEX_COUNT="count",FIELD_GROUP="group",FIELD_ORDER="order",INDEX_GROUP_AND_ORDER="group-order",KEY_ETAG="eTag",KEY_URL="url",KEY_PREFERRED_SKINTONE="skinTone",MODE_READONLY="readonly",MODE_READWRITE="readwrite",INDEX_SKIN_UNICODE="skinUnicodes",FIELD_SKIN_UNICODE="skinUnicodes",DEFAULT_DATA_SOURCE="/common/emoji-picker/data.json",DEFAULT_LOCALE="en";function uniqBy(e,t){const n=new Set,o=[];for(const r of e){const e=t(r);n.has(e)||(n.add(e),o.push(r))}return o}function uniqEmoji(e){return uniqBy(e,(e=>e.unicode))}function initialMigration(e){function t(t,n,o){const r=n?e.createObjectStore(t,{keyPath:n}):e.createObjectStore(t);if(o)for(const[e,[t,n]]of Object.entries(o))r.createIndex(e,t,{multiEntry:n});return r}t("keyvalue"),t("emoji","unicode",{[INDEX_TOKENS]:["tokens",!0],[INDEX_GROUP_AND_ORDER]:[["group","order"]],[INDEX_SKIN_UNICODE]:["skinUnicodes",!0]}),t("favorites",void 0,{[INDEX_COUNT]:[""]})}const openReqs={},databaseCache={},onCloseListeners={};function handleOpenOrDeleteReq(e,t,n){n.onerror=()=>t(n.error),n.onblocked=()=>t(new Error("IDB blocked")),n.onsuccess=()=>e(n.result)}async function createDatabase(e){const t=await new Promise(((t,n)=>{const o=indexedDB.open(e,1);openReqs[e]=o,o.onupgradeneeded=e=>{e.oldVersion<1&&initialMigration(o.result)},handleOpenOrDeleteReq(t,n,o)}));return t.onclose=()=>closeDatabase(e),t}function openDatabase(e){return databaseCache[e]||(databaseCache[e]=createDatabase(e)),databaseCache[e]}function dbPromise(e,t,n,o){return new Promise(((r,a)=>{const s=e.transaction(t,n,{durability:"relaxed"}),i="string"==typeof t?s.objectStore(t):t.map((e=>s.objectStore(e)));let c;o(i,s,(e=>{c=e})),s.oncomplete=()=>r(c),s.onerror=()=>a(s.error)}))}function closeDatabase(e){const t=openReqs[e],n=t&&t.result;if(n){n.close();const t=onCloseListeners[e];if(t)for(const e of t)e()}delete openReqs[e],delete databaseCache[e],delete onCloseListeners[e]}function deleteDatabase(e){return new Promise(((t,n)=>{closeDatabase(e);handleOpenOrDeleteReq(t,n,indexedDB.deleteDatabase(e))}))}function addOnCloseListener(e,t){let n=onCloseListeners[e];n||(n=onCloseListeners[e]=[]),n.push(t)}const irregularEmoticons=new Set([":D","XD",":'D","O:)",":X",":P",";P","XP",":L",":Z",":j","8D","XO","8)",":B",":O",":S",":'o","Dx","X(","D:",":C",">0)",":3","</3","<3","\\M/",":E","8#"]);function extractTokens(e){return e.split(/[\s_]+/).map((e=>!e.match(/\w/)||irregularEmoticons.has(e)?e.toLowerCase():e.replace(/[)(:,]/g,"").replace(/’/g,"'").toLowerCase())).filter(Boolean)}const MIN_SEARCH_TEXT_LENGTH=2;function normalizeTokens(e){return e.filter(Boolean).map((e=>e.toLowerCase())).filter((e=>e.length>=2))}function transformEmojiData(e){return e.map((({annotation:e,emoticon:t,group:n,order:o,shortcodes:r,skins:a,tags:s,emoji:i,version:c})=>{const u=[...new Set(normalizeTokens([...(r||[]).map(extractTokens).flat(),...s.map(extractTokens).flat(),...extractTokens(e),t]))].sort(),d={annotation:e,group:n,order:o,tags:s,tokens:u,unicode:i,version:c};if(t&&(d.emoticon=t),r&&(d.shortcodes=r),a){d.skinTones=[],d.skinUnicodes=[],d.skinVersions=[];for(const{tone:e,emoji:t,version:n}of a)d.skinTones.push(e),d.skinUnicodes.push(t),d.skinVersions.push(n)}return d}))}function callStore(e,t,n,o){e[t](n).onsuccess=e=>o&&o(e.target.result)}function getIDB(e,t,n){callStore(e,"get",t,n)}function getAllIDB(e,t,n){callStore(e,"getAll",t,n)}function commit(e){e.commit&&e.commit()}function minBy(e,t){let n=e[0];for(let o=1;o<e.length;o++){const r=e[o];t(n)>t(r)&&(n=r)}return n}function findCommonMembers(e,t){const n=minBy(e,(e=>e.length)),o=[];for(const r of n)e.some((e=>-1===e.findIndex((e=>t(e)===t(r)))))||o.push(r);return o}async function isEmpty(e){return!await get(e,"keyvalue",KEY_URL)}async function hasData(e,t,n){const[o,r]=await Promise.all([KEY_ETAG,KEY_URL].map((t=>get(e,"keyvalue",t))));return o===n&&r===t}async function doFullDatabaseScanForSingleResult(e,t){return dbPromise(e,"emoji","readonly",((e,n,o)=>{let r;const a=()=>{e.getAll(r&&IDBKeyRange.lowerBound(r,!0),50).onsuccess=e=>{const n=e.target.result;for(const e of n)if(r=e.unicode,t(e))return o(e);if(n.length<50)return o();a()}};a()}))}async function loadData(e,t,n,o){try{const r=transformEmojiData(t);await dbPromise(e,["emoji","keyvalue"],"readwrite",(([e,t],a)=>{let s,i,c=0;function u(){2==++c&&function(){if(s===o&&i===n)return;e.clear();for(const t of r)e.put(t);t.put(o,KEY_ETAG),t.put(n,KEY_URL),commit(a)}()}getIDB(t,KEY_ETAG,(e=>{s=e,u()})),getIDB(t,KEY_URL,(e=>{i=e,u()}))}))}finally{}}async function getEmojiByGroup(e,t){return dbPromise(e,"emoji","readonly",((e,n,o)=>{const r=IDBKeyRange.bound([t,0],[t+1,0],!1,!0);getAllIDB(e.index("group-order"),r,o)}))}async function getEmojiBySearchQuery(e,t){const n=normalizeTokens(extractTokens(t));return n.length?dbPromise(e,"emoji","readonly",((e,t,o)=>{const r=[],a=()=>{const e=findCommonMembers(r,(e=>e.unicode));o(e.sort(((e,t)=>e.order<t.order?-1:1)))};for(let t=0;t<n.length;t++){const o=n[t],s=t===n.length-1?IDBKeyRange.bound(o,o+"￿",!1,!0):IDBKeyRange.only(o);getAllIDB(e.index("tokens"),s,(e=>{r.push(e),r.length===n.length&&a()}))}})):[]}async function getEmojiByShortcode(e,t){const n=await getEmojiBySearchQuery(e,t);if(!n.length){const n=e=>(e.shortcodes||[]).includes(t.toLowerCase());return await doFullDatabaseScanForSingleResult(e,n)||null}return n.filter((e=>{const n=(e.shortcodes||[]).map((e=>e.toLowerCase()));return n.includes(t.toLowerCase())}))[0]||null}async function getEmojiByUnicode(e,t){return dbPromise(e,"emoji","readonly",((e,n,o)=>getIDB(e,t,(n=>{if(n)return o(n);getIDB(e.index("skinUnicodes"),t,(e=>o(e||null)))}))))}function get(e,t,n){return dbPromise(e,t,"readonly",((e,t,o)=>getIDB(e,n,o)))}function set(e,t,n,o){return dbPromise(e,t,"readwrite",((e,t)=>{e.put(o,n),commit(t)}))}function incrementFavoriteEmojiCount(e,t){return dbPromise(e,"favorites","readwrite",((e,n)=>getIDB(e,t,(o=>{e.put((o||0)+1,t),commit(n)}))))}function getTopFavoriteEmoji(e,t,n){return 0===n?[]:dbPromise(e,["favorites","emoji"],"readonly",(([e,o],r,a)=>{const s=[];e.index("count").openCursor(void 0,"prev").onsuccess=e=>{const r=e.target.result;if(!r)return a(s);function i(e){if(s.push(e),s.length===n)return a(s);r.continue()}const c=r.primaryKey,u=t.byName(c);if(u)return i(u);getIDB(o,c,(e=>{if(e)return i(e);r.continue()}))}}))}const CODA_MARKER="";function trie(e,t){const n=new Map;for(const o of e){const e=t(o);for(const t of e){let e=n;for(let n=0;n<t.length;n++){const o=t.charAt(n);let r=e.get(o);r||(r=new Map,e.set(o,r)),e=r}let r=e.get("");r||(r=[],e.set("",r)),r.push(o)}}return(e,t)=>{let o=n;for(let t=0;t<e.length;t++){const n=e.charAt(t),r=o.get(n);if(!r)return[];o=r}if(t){return o.get("")||[]}const r=[],a=[o];for(;a.length;){const e=[...a.shift().entries()].sort(((e,t)=>e[0]<t[0]?-1:1));for(const[t,n]of e)""===t?r.push(...n):a.push(n)}return r}}const requiredKeys$1=["name","url"];function assertCustomEmojis(e){const t=e&&Array.isArray(e),n=t&&e.length&&(!e[0]||requiredKeys$1.some((t=>!(t in e[0]))));if(!t||n)throw new Error("Custom emojis are in the wrong format")}function customEmojiIndex(e){assertCustomEmojis(e);const t=(e,t)=>e.name.toLowerCase()<t.name.toLowerCase()?-1:1,n=e.sort(t),o=trie(e,(e=>[...new Set((e.shortcodes||[]).map((e=>extractTokens(e))).flat())])),r=e=>o(e,!0),a=e=>o(e,!1),s=new Map,i=new Map;for(const t of e){i.set(t.name.toLowerCase(),t);for(const e of t.shortcodes||[])s.set(e.toLowerCase(),t)}return{all:n,search:e=>{const n=extractTokens(e);return findCommonMembers(n.map(((e,t)=>(t<n.length-1?r:a)(e))),(e=>e.name)).sort(t)},byShortcode:e=>s.get(e.toLowerCase()),byName:e=>i.get(e.toLowerCase())}}function cleanEmoji(e){if(!e)return e;if(delete e.tokens,e.skinTones){const t=e.skinTones.length;e.skins=Array(t);for(let n=0;n<t;n++)e.skins[n]={tone:e.skinTones[n],unicode:e.skinUnicodes[n],version:e.skinVersions[n]};delete e.skinTones,delete e.skinUnicodes,delete e.skinVersions}return e}function warnETag(e){e||console.warn("emoji-picker-element is more efficient if the dataSource server exposes an ETag header.")}const requiredKeys=["annotation","emoji","group","order","tags","version"];function assertEmojiData(e){if(!e||!Array.isArray(e)||!e[0]||"object"!=typeof e[0]||requiredKeys.some((t=>!(t in e[0]))))throw new Error("Emoji data is in the wrong format")}function assertStatus(e,t){if(2!==Math.floor(e.status/100))throw new Error("Failed to fetch: "+t+":  "+e.status)}async function getETag(e){const t=await fetch(e,{method:"HEAD"});assertStatus(t,e);const n=t.headers.get("etag");return warnETag(n),n}async function getETagAndData(e){const t=await fetch(e);assertStatus(t,e);const n=t.headers.get("etag");warnETag(n);const o=await t.json();return assertEmojiData(o),[n,o]}function arrayBufferToBinaryString(e){for(var t="",n=new Uint8Array(e),o=n.byteLength,r=-1;++r<o;)t+=String.fromCharCode(n[r]);return t}function binaryStringToArrayBuffer(e){for(var t=e.length,n=new ArrayBuffer(t),o=new Uint8Array(n),r=-1;++r<t;)o[r]=e.charCodeAt(r);return n}async function jsonChecksum(e){const t=binaryStringToArrayBuffer(JSON.stringify(e)),n=arrayBufferToBinaryString(await crypto.subtle.digest("SHA-1",t));return btoa(n)}async function checkForUpdates(e,t){let n,o=await getETag(t);if(!o){const e=await getETagAndData(t);o=e[0],n=e[1],o||(o=await jsonChecksum(n))}if(await hasData(e,t,o));else{if(!n){n=(await getETagAndData(t))[1]}await loadData(e,n,t,o)}}async function loadDataForFirstTime(e,t){let[n,o]=await getETagAndData(t);n||(n=await jsonChecksum(o)),await loadData(e,o,t,n)}class Database{constructor({dataSource:e=DEFAULT_DATA_SOURCE,locale:t="en",customEmoji:n=[]}={}){this.dataSource=e,this.locale=t,this._dbName=`emoji-picker-element-${this.locale}`,this._db=void 0,this._lazyUpdate=void 0,this._custom=customEmojiIndex(n),this._clear=this._clear.bind(this),this._ready=this._init()}async _init(){const e=this._db=await openDatabase(this._dbName);addOnCloseListener(this._dbName,this._clear);const t=this.dataSource;await isEmpty(e)?await loadDataForFirstTime(e,t):this._lazyUpdate=checkForUpdates(e,t)}async ready(){const e=async()=>(this._ready||(this._ready=this._init()),this._ready);await e(),this._db||await e()}async getEmojiByGroup(e){return assertNumber(e),await this.ready(),uniqEmoji(await getEmojiByGroup(this._db,e)).map(cleanEmoji)}async getEmojiBySearchQuery(e){assertNonEmptyString(e),await this.ready();return[...this._custom.search(e),...uniqEmoji(await getEmojiBySearchQuery(this._db,e)).map(cleanEmoji)]}async getEmojiByShortcode(e){assertNonEmptyString(e),await this.ready();const t=this._custom.byShortcode(e);return t||cleanEmoji(await getEmojiByShortcode(this._db,e))}async getEmojiByUnicodeOrName(e){assertNonEmptyString(e),await this.ready();const t=this._custom.byName(e);return t||cleanEmoji(await getEmojiByUnicode(this._db,e))}async getPreferredSkinTone(){return await this.ready(),await get(this._db,"keyvalue","skinTone")||0}async setPreferredSkinTone(e){return assertNumber(e),await this.ready(),set(this._db,"keyvalue","skinTone",e)}async incrementFavoriteEmojiCount(e){return assertNonEmptyString(e),await this.ready(),incrementFavoriteEmojiCount(this._db,e)}async getTopFavoriteEmoji(e){return assertNumber(e),await this.ready(),(await getTopFavoriteEmoji(this._db,this._custom,e)).map(cleanEmoji)}set customEmoji(e){this._custom=customEmojiIndex(e)}get customEmoji(){return this._custom.all}async _shutdown(){await this.ready();try{await this._lazyUpdate}catch(e){}}_clear(){this._db=this._ready=this._lazyUpdate=void 0}async close(){await this._shutdown(),await closeDatabase(this._dbName)}async delete(){await this._shutdown(),await deleteDatabase(this._dbName)}}export default Database;